<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1"
    />
    <title>hurricane-map 3D</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.111.0/Cesium.js" integrity="sha512-VjMfxVEXtb4RIAA9CZZaAmxzWGHBU/CAAiSn/mJ47qClQzhtWo//gnPV0otnVL9TflseucJNvU5v6aryqByAsw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  </head>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    .cesium-viewer-animationContainer {
      display: none;
    }
    .cesium-viewer-timelineContainer {
      display: none;
    }
    .cesium-widget-credits {
      opacity: 0;
    }
  </style>
  <body>
  <div id="cesiumContainer" style="width: 100vw; height: 100vh"></div>
  </body>
  <script>
  window.startup = async function (Cesium) {
      'use strict';
      const viewer = new Cesium.Viewer("cesiumContainer", {
        homeButton: false,
        navigationHelpButton: false,
        sceneModePicker: false,
        timeline: false,
        baseLayerPicker: false,
      });
      const scene = viewer.scene;
      const globe = scene.globe;
      const skyAtmosphere = scene.skyAtmosphere;

      scene.highDynamicRange = true;
      globe.enableLighting = true;
      globe.atmosphereLightIntensity = 20.0;

      const defaultGroundAtmosphereLightIntensity =
        globe.atmosphereLightIntensity;
      const defaultGroundAtmosphereRayleighCoefficient =
        globe.atmosphereRayleighCoefficient;
      const defaultGroundAtmosphereMieCoefficient =
        globe.atmosphereMieCoefficient;
      const defaultGroundAtmosphereMieAnisotropy =
        globe.atmosphereMieAnisotropy;
      const defaultGroundAtmosphereRayleighScaleHeight =
        globe.atmosphereRayleighScaleHeight;
      const defaultGroundAtmosphereMieScaleHeight =
        globe.atmosphereMieScaleHeight;
      const defaultGroundAtmosphereHueShift = globe.atmosphereHueShift;
      const defaultGroundAtmosphereSaturationShift =
        globe.atmosphereSaturationShift;
      const defaultGroundAtmosphereBrightnessShift =
        globe.atmosphereBrightnessShift;
      const defaultLightFadeOut = globe.lightingFadeOutDistance;
      const defaultLightFadeIn = globe.lightingFadeInDistance;
      const defaultNightFadeOut = globe.nightFadeOutDistance;
      const defaultNightFadeIn = globe.nightFadeInDistance;

      const defaultSkyAtmosphereLightIntensity =
        skyAtmosphere.atmosphereLightIntensity;
      const defaultSkyAtmosphereRayleighCoefficient =
        skyAtmosphere.atmosphereRayleighCoefficient;
      const defaultSkyAtmosphereMieCoefficient =
        skyAtmosphere.atmosphereMieCoefficient;
      const defaultSkyAtmosphereMieAnisotropy =
        skyAtmosphere.atmosphereMieAnisotropy;
      const defaultSkyAtmosphereRayleighScaleHeight =
        skyAtmosphere.atmosphereRayleighScaleHeight;
      const defaultSkyAtmosphereMieScaleHeight =
        skyAtmosphere.atmosphereMieScaleHeight;
      const defaultSkyAtmosphereHueShift = skyAtmosphere.hueShift;
      const defaultSkyAtmosphereSaturationShift =
        skyAtmosphere.saturationShift;
      const defaultSkyAtmosphereBrightnessShift =
        skyAtmosphere.brightnessShift;

      const viewModel = {
        // Globe settings

        enableTerrain: false,
        enableLighting: true,
        groundTranslucency: false,

        // Ground atmosphere settings

        showGroundAtmosphere: true,
        groundAtmosphereLightIntensity: defaultGroundAtmosphereLightIntensity,
        groundAtmosphereRayleighCoefficientR:
          defaultGroundAtmosphereRayleighCoefficient.x / 1e-6,
        groundAtmosphereRayleighCoefficientG:
          defaultGroundAtmosphereRayleighCoefficient.y / 1e-6,
        groundAtmosphereRayleighCoefficientB:
          defaultGroundAtmosphereRayleighCoefficient.z / 1e-6,
        groundAtmosphereMieCoefficient:
          defaultGroundAtmosphereMieCoefficient.x / 1e-6,
        groundAtmosphereRayleighScaleHeight: defaultGroundAtmosphereRayleighScaleHeight,
        groundAtmosphereMieScaleHeight: defaultGroundAtmosphereMieScaleHeight,
        groundAtmosphereMieAnisotropy: defaultGroundAtmosphereMieAnisotropy,
        groundHueShift: defaultGroundAtmosphereHueShift,
        groundSaturationShift: defaultGroundAtmosphereSaturationShift,
        groundBrightnessShift: defaultGroundAtmosphereBrightnessShift,
        lightingFadeOutDistance: defaultLightFadeOut,
        lightingFadeInDistance: defaultLightFadeIn,
        nightFadeOutDistance: defaultNightFadeOut,
        nightFadeInDistance: defaultNightFadeIn,

        // Sky atmosphere settings

        showSkyAtmosphere: true,
        skyAtmosphereLightIntensity: defaultSkyAtmosphereLightIntensity,
        skyAtmosphereRayleighCoefficientR:
          defaultSkyAtmosphereRayleighCoefficient.x / 1e-6,
        skyAtmosphereRayleighCoefficientG:
          defaultSkyAtmosphereRayleighCoefficient.y / 1e-6,
        skyAtmosphereRayleighCoefficientB:
          defaultSkyAtmosphereRayleighCoefficient.z / 1e-6,
        skyAtmosphereMieCoefficient:
          defaultSkyAtmosphereMieCoefficient.x / 1e-6,
        skyAtmosphereRayleighScaleHeight: defaultSkyAtmosphereRayleighScaleHeight,
        skyAtmosphereMieScaleHeight: defaultSkyAtmosphereMieScaleHeight,
        skyAtmosphereMieAnisotropy: defaultSkyAtmosphereMieAnisotropy,
        skyHueShift: defaultSkyAtmosphereHueShift,
        skySaturationShift: defaultSkyAtmosphereSaturationShift,
        skyBrightnessShift: defaultSkyAtmosphereBrightnessShift,
        perFragmentAtmosphere: false,
        dynamicLighting: true,
        dynamicLightingFromSun: false,

        // Fog settings

        showFog: true,
        density: 1.0,
        minimumBrightness: 0.03,

        // Scene settings

        hdr: true,
    };
    fetchLiveStorms().then(data => {
      if (data) {
        console.log('Forecasts data:', data);
        const groupedStorms = groupData(data);
        plotStorms(groupedStorms, viewer);
        const strongestStorm = findHighestWindSpeedEntry(groupedStorms);
        centerCameraOnLocation(viewer, strongestStorm.lat, strongestStorm.lon);
        createForecastMarkers(viewer);
      } else {
        console.log('Failed to fetch forecasts data.');
      }
    });
  };
  async function fetchLiveStorms() {
    try {
        const response = await fetch('http://fluids.ai:1337/live-storms'); // Replace with your API endpoint
        if (!response.ok) {
            throw new Error(`HTTP error: ${response.status}`);
        }
        const liveStorms = await response.json();
        return liveStorms;
    } catch (error) {
        console.error('Error fetching live storms:', error);
        return null;
    }
  }
  function groupData(data) {
    const groupedData = {};
    data.forEach(item => {
        const id = item.id;
        if (!groupedData[id]) {
            groupedData[id] = [];
        }
        groupedData[id].push(item);
    });
    return groupedData;
  }
  function saffirSimpsonCategory(knots) {
    // Calculate the category based on knots
    if(knots < 64) {
        return 'storm';
    } else if(knots <= 82) {
        return 'cat1';
    } else if(knots <= 95) {
        return 'cat2';
    } else if(knots <= 113) {
        return 'cat3';
    } else if(knots <= 136) {
        return 'cat4';
    } else {
        return 'cat5';
    }
  }
  function plotStorms(groupedData, viewer) {
    Object.values(groupedData).forEach(storms => {
        const positions = [];
        storms.forEach(storm => {
            const position = Cesium.Cartesian3.fromDegrees(storm.lon, storm.lat);
            positions.push(position);

            // Add a marker for each storm point
            viewer.entities.add({
                position: position,
                point: {
                    pixelSize: 50,
                    color: Cesium.Color.fromCssColorString(
                        getColorCode(parseFloat(storm.wind_speed))
                      ).withAlpha(0.8)
                }
            });

            // Add a billboard as a marker for each storm point
            let category = saffirSimpsonCategory(parseFloat(storm.wind_speed));
            viewer.entities.add({
                position: position,
                billboard: {
                    image: `static/${category}.png`,
                    scaleByDistance: new Cesium.NearFarScalar(-5000, 0.2, 8000000, 0.02)
                }
            });
        });
        // Add a line to connect the storm points
        viewer.entities.add({
            polyline: {
                positions: positions,
                width: 2,
                material: Cesium.Color.RED
            }
        });
    });
  }
  function getColorCode(knots) {
    if (knots < 34) {
        return "#008000"; // Tropical Depression - Green
    } else if (knots >= 34 && knots <= 63) {
        return "#FFFF00"; // Tropical Storm - Yellow
    } else if (knots >= 64 && knots <= 82) {
        return "#FFC0C0"; // Category 1 - Light Red
    } else if (knots >= 83 && knots <= 95) {
        return "#FF8080"; // Category 2 - Medium Light Red
    } else if (knots >= 96 && knots <= 112) {
        return "#FF4040"; // Category 3 - Medium Red
    } else if (knots >= 113 && knots <= 135) {
        return "#FF0000"; // Category 4 - Dark Red
    } else {
        return "#8B0000"; // Category 5 - Very Dark Red
    }
  }
  function findMostRecentEntries(groupedData) {
    const mostRecentEntries = {};

    Object.keys(groupedData).forEach(stormId => {
        let mostRecentEntry = null;
        let mostRecentTime = 0;

        groupedData[stormId].forEach(entry => {
            const entryTime = new Date(entry.time).getTime(); // Assuming 'time' is in a format that can be parsed to a Date object

            if (mostRecentEntry === null || entryTime > mostRecentTime) {
                mostRecentEntry = entry;
                mostRecentTime = entryTime;
            }
        });

        mostRecentEntries[stormId] = mostRecentEntry;
    });

    return mostRecentEntries;
  }
  function findHighestWindSpeedEntry(groupedData) {
    const mostRecentEntries = findMostRecentEntries(groupedData);
    let highestWindSpeedEntry = null;
    let highestWindSpeed = -1;

    Object.values(mostRecentEntries).forEach(entry => {
        if (entry.wind_speed > highestWindSpeed) {
            highestWindSpeed = entry.wind_speed;
            highestWindSpeedEntry = entry;
        }
    });

    return highestWindSpeedEntry;
  }
  function centerCameraOnLocation(viewer, latitude, longitude, zoomLevel = 10000000) {
    // Check if viewer, latitude, and longitude are provided
    if (!viewer || latitude === undefined || longitude === undefined) {
        console.error("Invalid arguments. Viewer, latitude and longitude are required.");
        return;
    }

    // Convert latitude and longitude to Cartesian3 coordinates
    const destination = Cesium.Cartesian3.fromDegrees(longitude, latitude, zoomLevel);

    // Set the camera to look at the specified location
    viewer.camera.flyTo({
        destination: destination,
        orientation: {
            heading: Cesium.Math.toRadians(0), // East, default orientation
            pitch: Cesium.Math.toRadians(-90), // Look directly at the target
            roll: 0.0
        },
        duration: 2 // Duration in seconds for the camera flight
    });
  }
  async function fetchForecasts() {
    try {
      const response = await fetch('http://fluids.ai:1337/forecasts');

      // Check if the request was successful
      if (!response.ok) {
        throw new Error(`HTTP error: ${response.status}`);
      }

      // Parse the response as JSON
      const jsonData = await response.json();

      // Filter out the models that are defined as 'gpt-3.5-turbo'
      const filteredData = jsonData.filter(item => item.model !== 'gpt-3.5-turbo');
      return filteredData;
    } catch (error) {
      console.error('Error fetching forecasts:', error);
      return null;
    }
  }
  async function createForecastMarkers(viewer) {
    const forecasts = await fetchForecasts();
    if (!forecasts) {
        console.error('Failed to fetch forecasts');
        return;
    }

    const groupedForecasts = {};

    // Group forecasts by model and then by storm ID
    forecasts.forEach(forecast => {
        if (!groupedForecasts[forecast.model]) {
            groupedForecasts[forecast.model] = {};
        }
        if (!groupedForecasts[forecast.model][forecast.id]) {
            groupedForecasts[forecast.model][forecast.id] = [];
        }
        groupedForecasts[forecast.model][forecast.id].push(forecast);
    });

    Object.keys(groupedForecasts).forEach(model => {
        Object.keys(groupedForecasts[model]).forEach(stormId => {
            let positions = [];
            let prevForecast = null;

            groupedForecasts[model][stormId].forEach(forecast => {
                const position = Cesium.Cartesian3.fromDegrees(forecast.lon, forecast.lat);

                // Add a marker for each forecast point
                viewer.entities.add({
                    position: position,
                    point: {
                        pixelSize: 5,
                        color: Cesium.Color.WHITE,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 1
                    },
                    description: `
                        <h4>Forecast Details</h4>
                        <ul>
                            <li><strong>Model:</strong> ${forecast.model}</li>
                            <li><strong>ID:</strong> ${forecast.id}</li>
                            <li><strong>Time:</strong> ${forecast.time}</li>
                            <li><strong>Latitude:</strong> ${forecast.lat}</li>
                            <li><strong>Longitude:</strong> ${forecast.lon}</li>
                            <li><strong>Wind Speed:</strong> ${forecast.wind_speed} knots</li>
                        </ul>
                    `
                });

                if (prevForecast && Math.abs(prevForecast.lon - forecast.lon) > 180) {
                    // Handle crossing the International Date Line
                    viewer.entities.add({
                        polyline: {
                            positions: positions,
                            width: 2,
                            material: Cesium.Color.RED.withAlpha(0.5)
                        }
                    });
                    positions = [];
                }
                prevForecast = forecast;
                positions.push(position);
            });

            if (positions.length > 0) {
                // Create and add the polyline for the current storm ID group
                viewer.entities.add({
                    polyline: {
                        positions: positions,
                        width: 2,
                        material: Cesium.Color.RED.withAlpha(0.5)
                    }
                });
            }
        });
    });
  }

  if (typeof Cesium !== 'undefined') {
      window.startupCalled = true;
      window.startup(Cesium).catch((error) => {
        "use strict";
        console.error(error);
      });
  }
</script>
</html>
