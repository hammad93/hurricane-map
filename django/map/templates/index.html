<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1"
    />
    <title>hurricane-map 3D</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.111.0/Cesium.js" integrity="sha512-VjMfxVEXtb4RIAA9CZZaAmxzWGHBU/CAAiSn/mJ47qClQzhtWo//gnPV0otnVL9TflseucJNvU5v6aryqByAsw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  </head>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    .cesium-viewer-animationContainer {
      display: none;
    }
    .cesium-viewer-timelineContainer {
      display: none;
    }
    .cesium-widget-credits {
      opacity: 0;
    }
  </style>
  <body>
  <div id="cesiumContainer" style="width: 100vw; height: 100vh"></div>
  </body>
  <script>
  window.startup = async function (Cesium) {
      'use strict';
      const viewer = new Cesium.Viewer("cesiumContainer", {
        homeButton: false,
        navigationHelpButton: false,
        sceneModePicker: false,
        timeline: false,
        baseLayerPicker: false,
      });
      const scene = viewer.scene;
      const globe = scene.globe;
      const skyAtmosphere = scene.skyAtmosphere;

      scene.highDynamicRange = true;
      globe.enableLighting = true;
      globe.atmosphereLightIntensity = 20.0;

      const defaultGroundAtmosphereLightIntensity =
        globe.atmosphereLightIntensity;
      const defaultGroundAtmosphereRayleighCoefficient =
        globe.atmosphereRayleighCoefficient;
      const defaultGroundAtmosphereMieCoefficient =
        globe.atmosphereMieCoefficient;
      const defaultGroundAtmosphereMieAnisotropy =
        globe.atmosphereMieAnisotropy;
      const defaultGroundAtmosphereRayleighScaleHeight =
        globe.atmosphereRayleighScaleHeight;
      const defaultGroundAtmosphereMieScaleHeight =
        globe.atmosphereMieScaleHeight;
      const defaultGroundAtmosphereHueShift = globe.atmosphereHueShift;
      const defaultGroundAtmosphereSaturationShift =
        globe.atmosphereSaturationShift;
      const defaultGroundAtmosphereBrightnessShift =
        globe.atmosphereBrightnessShift;
      const defaultLightFadeOut = globe.lightingFadeOutDistance;
      const defaultLightFadeIn = globe.lightingFadeInDistance;
      const defaultNightFadeOut = globe.nightFadeOutDistance;
      const defaultNightFadeIn = globe.nightFadeInDistance;

      const defaultSkyAtmosphereLightIntensity =
        skyAtmosphere.atmosphereLightIntensity;
      const defaultSkyAtmosphereRayleighCoefficient =
        skyAtmosphere.atmosphereRayleighCoefficient;
      const defaultSkyAtmosphereMieCoefficient =
        skyAtmosphere.atmosphereMieCoefficient;
      const defaultSkyAtmosphereMieAnisotropy =
        skyAtmosphere.atmosphereMieAnisotropy;
      const defaultSkyAtmosphereRayleighScaleHeight =
        skyAtmosphere.atmosphereRayleighScaleHeight;
      const defaultSkyAtmosphereMieScaleHeight =
        skyAtmosphere.atmosphereMieScaleHeight;
      const defaultSkyAtmosphereHueShift = skyAtmosphere.hueShift;
      const defaultSkyAtmosphereSaturationShift =
        skyAtmosphere.saturationShift;
      const defaultSkyAtmosphereBrightnessShift =
        skyAtmosphere.brightnessShift;

      const viewModel = {
        // Globe settings

        enableTerrain: false,
        enableLighting: true,
        groundTranslucency: false,

        // Ground atmosphere settings

        showGroundAtmosphere: true,
        groundAtmosphereLightIntensity: defaultGroundAtmosphereLightIntensity,
        groundAtmosphereRayleighCoefficientR:
          defaultGroundAtmosphereRayleighCoefficient.x / 1e-6,
        groundAtmosphereRayleighCoefficientG:
          defaultGroundAtmosphereRayleighCoefficient.y / 1e-6,
        groundAtmosphereRayleighCoefficientB:
          defaultGroundAtmosphereRayleighCoefficient.z / 1e-6,
        groundAtmosphereMieCoefficient:
          defaultGroundAtmosphereMieCoefficient.x / 1e-6,
        groundAtmosphereRayleighScaleHeight: defaultGroundAtmosphereRayleighScaleHeight,
        groundAtmosphereMieScaleHeight: defaultGroundAtmosphereMieScaleHeight,
        groundAtmosphereMieAnisotropy: defaultGroundAtmosphereMieAnisotropy,
        groundHueShift: defaultGroundAtmosphereHueShift,
        groundSaturationShift: defaultGroundAtmosphereSaturationShift,
        groundBrightnessShift: defaultGroundAtmosphereBrightnessShift,
        lightingFadeOutDistance: defaultLightFadeOut,
        lightingFadeInDistance: defaultLightFadeIn,
        nightFadeOutDistance: defaultNightFadeOut,
        nightFadeInDistance: defaultNightFadeIn,

        // Sky atmosphere settings

        showSkyAtmosphere: true,
        skyAtmosphereLightIntensity: defaultSkyAtmosphereLightIntensity,
        skyAtmosphereRayleighCoefficientR:
          defaultSkyAtmosphereRayleighCoefficient.x / 1e-6,
        skyAtmosphereRayleighCoefficientG:
          defaultSkyAtmosphereRayleighCoefficient.y / 1e-6,
        skyAtmosphereRayleighCoefficientB:
          defaultSkyAtmosphereRayleighCoefficient.z / 1e-6,
        skyAtmosphereMieCoefficient:
          defaultSkyAtmosphereMieCoefficient.x / 1e-6,
        skyAtmosphereRayleighScaleHeight: defaultSkyAtmosphereRayleighScaleHeight,
        skyAtmosphereMieScaleHeight: defaultSkyAtmosphereMieScaleHeight,
        skyAtmosphereMieAnisotropy: defaultSkyAtmosphereMieAnisotropy,
        skyHueShift: defaultSkyAtmosphereHueShift,
        skySaturationShift: defaultSkyAtmosphereSaturationShift,
        skyBrightnessShift: defaultSkyAtmosphereBrightnessShift,
        perFragmentAtmosphere: false,
        dynamicLighting: true,
        dynamicLightingFromSun: false,

        // Fog settings

        showFog: true,
        density: 1.0,
        minimumBrightness: 0.03,

        // Scene settings

        hdr: true,
    };
    fetchLiveStorms().then(data => {
      if (data) {
        console.log('Forecasts data:', data);
        const groupedStorms = groupData(data);
        plotStorms(groupedStorms, viewer);
      } else {
        console.log('Failed to fetch forecasts data.');
      }
    });
  };
  async function fetchLiveStorms() {
    try {
        const response = await fetch('http://fluids.ai:1337/live-storms'); // Replace with your API endpoint
        if (!response.ok) {
            throw new Error(`HTTP error: ${response.status}`);
        }
        const liveStorms = await response.json();
        return liveStorms;
    } catch (error) {
        console.error('Error fetching live storms:', error);
        return null;
    }
  }
  function groupData(data) {
    const groupedData = {};
    data.forEach(item => {
        const id = item.id;
        if (!groupedData[id]) {
            groupedData[id] = [];
        }
        groupedData[id].push(item);
    });
    return groupedData;
  }
  function saffirSimpsonCategory(knots) {
    // Calculate the category based on knots
    if(knots < 64) {
        return 'storm';
    } else if(knots <= 82) {
        return 'cat1';
    } else if(knots <= 95) {
        return 'cat2';
    } else if(knots <= 113) {
        return 'cat3';
    } else if(knots <= 136) {
        return 'cat4';
    } else {
        return 'cat5';
    }
  }
  function plotStorms(groupedData, viewer) {
    Object.values(groupedData).forEach(storms => {
        const positions = [];
        storms.forEach(storm => {
            const position = Cesium.Cartesian3.fromDegrees(storm.lon, storm.lat);
            positions.push(position);

            // Add a marker for each storm point
            viewer.entities.add({
                position: position,
                point: {
                    pixelSize: 50,
                    color: Cesium.Color.fromCssColorString(
                        getColorCode(parseFloat(storm.wind_speed))
                      ).withAlpha(0.8)
                }
            });

            // Add a billboard as a marker for each storm point
            let category = saffirSimpsonCategory(parseFloat(storm.wind_speed));
            viewer.entities.add({
                position: position,
                billboard: {
                    image: `static/${category}.png`,
                    scaleByDistance: new Cesium.NearFarScalar(-5000, 0.2, 8000000, 0.02)
                }
            });
        });
        // Add a line to connect the storm points
        viewer.entities.add({
            polyline: {
                positions: positions,
                width: 2,
                material: Cesium.Color.RED
            }
        });
    });
  }
  function getColorCode(knots) {
    if (knots < 34) {
        return "#008000"; // Tropical Depression - Green
    } else if (knots >= 34 && knots <= 63) {
        return "#FFFF00"; // Tropical Storm - Yellow
    } else if (knots >= 64 && knots <= 82) {
        return "#FFC0C0"; // Category 1 - Light Red
    } else if (knots >= 83 && knots <= 95) {
        return "#FF8080"; // Category 2 - Medium Light Red
    } else if (knots >= 96 && knots <= 112) {
        return "#FF4040"; // Category 3 - Medium Red
    } else if (knots >= 113 && knots <= 135) {
        return "#FF0000"; // Category 4 - Dark Red
    } else {
        return "#8B0000"; // Category 5 - Very Dark Red
    }
  }
  if (typeof Cesium !== 'undefined') {
      window.startupCalled = true;
      window.startup(Cesium).catch((error) => {
        "use strict";
        console.error(error);
      });
  }
</script>
</html>
